# 作业2 (Sep/18/2018)
1. 用你的语言描述图灵为什么要证明停机问题，其证明方法和数学原理是什么。

答：图灵通过停机问题回应“这个计算机是否在某些输入下停机”（即希尔伯特的“任意一个方程有没有有理数解”），并证明了此问题和一阶逻辑的不可判定性。
   
   以下为图灵的证明方法：
   
   a. 存在一个解决这个问题的算法G，如果输入可停机便回复“1”，不可停机便回复“0”。
   
   b. 假设有一个算法H，以G为输入。如果G=1便回复“0”，G=0便回复“1”。
   
   c. 使用H(H)。如果H=0，H(H)=1；如果H=1，H(H)=0。
   
   ∴不存在一个可以解决停机问题的算法（反证）


2. 你在向中学生做科普，请向他们解释二进制补码的原理。

答：二进制补码是一种表示正负整数的表示法。他解决了原码和反码的问题，是当下最常见的表示法。

   原码就是用最左边的一位表示正负，如0100 = 4和1100 = -4。但是这个表示法因为其最左边的一位不是一个数字，所以在计算上有一定的麻烦，且此表示法有正负两个零。为了解决这个问题，反码就被提出来了。

   反码表示法中的正数使用原码，而负数使用反码，如0100 = 4和1011 = -4。反码中的最左一位可以像数字一样使用，在计算中比原码方便，但是它还是无法解决正负 两个零的问题，因此后来就推出了二进制补码。

   二进制补码就是负数在反码的基础上加1，如0100 = 4和1100 = -4。二进制补码解决了两个零的问题。二进制补码因为少了一个零（原在反码和原码中的全1），便多出了一个负数的名额，于是4-bits可以表示-8 至 7。 二进制补码也能够判定overflow的情况，如果两个正数的相加得出一个负数，或两个负数的相加得出正数，那么便可判定算法超出范围。

3. 某基于IEEE 754浮点数格式的 16 bit 浮点数表示，有 8 个小数位，请给出 ±0，±1.0，最大非规范化数，最小非规范化数，最小规范化浮点数，最大规范化浮点数，±∞，NaN 的二进制表示(表示形式请参照讲义)。
答：
   | Sign | Exp | Frac | Value |
   | --- | --- | --- | --- |
   | * | 00000 | 0000000000 | ±0 |   
   | 0 | 01111 | 0000000000 | +1 |   
   | 1 | 01111 | 0000000000 | -1 |   
   | * | 00000 | 1111111111 | 最大非规范化数 |   
   | * | 00000 | 0000000001 | 最小非规范化数 |   
   | * | 11110 | 1111111111 | 最大规范化浮点数 |   
   | * | 00001 | 0000000000 | 最小规范化浮点数 |   
   | * | 11111 | 0000000000 | ±∞ |   
   | * | 11111 | non zero | NaN |
